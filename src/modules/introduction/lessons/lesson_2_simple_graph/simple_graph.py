"""
Simple Graph Application - Lesson 2

This module demonstrates the fundamental concepts of LangGraph:
- State management with TypedDict
- Node functions
- Graph structure and compilation
- Basic application workflow

This serves as the foundation for more complex LangGraph applications.
"""

from typing import TypedDict
from langgraph.graph import StateGraph


class GraphState(TypedDict):
    """
    State schema for the simple graph application.
    
    Attributes:
        message: The input message from the user
        response: The response generated by the graph
    """
    message: str
    response: str


def create_state_schema() -> type[GraphState]:
    """
    Create and return the state schema for the graph.
    
    Returns:
        The GraphState TypedDict class defining the state structure
    """
    return GraphState


def process_message(state: GraphState) -> GraphState:
    """
    Simple node function that processes the input message and generates a response.
    
    This function demonstrates the basic structure of a LangGraph node:
    - Takes state as input
    - Processes the state
    - Returns updated state
    
    Args:
        state: The current graph state containing message and response
        
    Returns:
        dict: Updated state with the response field populated
    """
    # Extract the message from the current state
    message = state.get("message", "")
    
    # Simple processing logic (placeholder for future LLM integration)
    if not message:
        response = "No message provided."
    elif message.lower().startswith("hello"):
        response = f"Hello! I received your message: '{message}'"
    elif message.lower().startswith("help"):
        response = "I'm here to help! What would you like to know?"
    else:
        response = f"I processed your message: '{message}'. This is a simple response."
    
    # Return updated state
    return {
        "message": message,
        "response": response
    }


def test_node_function():
    """
    Test function to verify the node function works correctly.
    
    Returns:
        bool: True if all tests pass, False otherwise
    """
    try:
        # Test 1: Test with empty message
        empty_state: GraphState = {"message": "", "response": ""}
        result = process_message(empty_state)
        assert result["response"] == "No message provided."
        
        # Test 2: Test with hello message
        hello_state: GraphState = {"message": "Hello, world!", "response": ""}
        result = process_message(hello_state)
        assert "Hello! I received your message" in result["response"]
        
        # Test 3: Test with help message
        help_state: GraphState = {"message": "Help me please", "response": ""}
        result = process_message(help_state)
        assert "I'm here to help" in result["response"]
        
        # Test 4: Test with regular message
        regular_state: GraphState = {"message": "This is a test", "response": ""}
        result = process_message(regular_state)
        assert "I processed your message" in result["response"]
        
        # Test 5: Verify state structure is maintained
        assert "message" in result
        assert "response" in result
        assert result["message"] == "This is a test"
        
        print("✅ Node function tests passed!")
        return True
        
    except Exception as e:
        print(f"❌ Node function test failed: {e}")
        return False


def test_state_schema():
    """
    Test function to verify the state schema works correctly.
    
    Returns:
        bool: True if all tests pass, False otherwise
    """
    try:
        # Test 1: Create state schema
        state_schema = create_state_schema()
        
        # Test 2: Create a valid state instance
        test_state = {
            "message": "Hello, world!",
            "response": ""
        }
        
        # Test 3: Verify state structure
        assert "message" in test_state
        assert "response" in test_state
        assert isinstance(test_state["message"], str)
        assert isinstance(test_state["response"], str)
        
        # Test 4: Create StateGraph with schema
        graph = StateGraph(state_schema)
        
        print("✅ State schema tests passed!")
        return True
        
    except Exception as e:
        print(f"❌ State schema test failed: {e}")
        return False


def create_simple_graph():
    """
    Create a simple graph with a single node that processes messages.
    
    This function demonstrates:
    - Creating a StateGraph with state schema
    - Adding nodes to the graph
    - Setting entry and finish points
    - Compiling the graph into a runnable application
    
    Returns:
        Compiled graph application ready for invocation
    """
    # Create state schema
    state_schema = create_state_schema()
    
    # Create the graph
    graph = StateGraph(state_schema)
    
    # Add the processing node to the graph
    graph.add_node("process_message", process_message)
    
    # Set the entry point (where execution starts)
    graph.set_entry_point("process_message")
    
    # Set the finish point (where execution ends)
    graph.set_finish_point("process_message")
    
    # Compile the graph into a runnable application
    app = graph.compile()
    
    return app


def test_graph_structure():
    """
    Test function to verify the graph structure is correct.
    
    Returns:
        bool: True if all tests pass, False otherwise
    """
    try:
        # Test 1: Create graph
        app = create_simple_graph()
        
        # Test 2: Verify compiled app has expected methods
        assert hasattr(app, 'invoke')
        assert hasattr(app, 'stream')
        
        # Test 3: Test basic invocation
        initial_state: GraphState = {
            "message": "Hello, graph!",
            "response": ""
        }
        
        result = app.invoke(initial_state)
        
        # Test 4: Verify result structure
        assert "message" in result
        assert "response" in result
        assert result["message"] == "Hello, graph!"
        assert len(result["response"]) > 0
        
        print("✅ Graph structure tests passed!")
        return True
        
    except Exception as e:
        print(f"❌ Graph structure test failed: {e}")
        return False


def test_complete_application():
    """
    Test the complete application workflow.
    
    Returns:
        bool: True if all tests pass, False otherwise
    """
    try:
        # Create the application
        app = create_simple_graph()
        
        # Test cases
        test_cases = [
            {
                "input": {"message": "", "response": ""},
                "expected_contains": "No message provided"
            },
            {
                "input": {"message": "Hello there!", "response": ""},
                "expected_contains": "Hello! I received your message"
            },
            {
                "input": {"message": "Help me", "response": ""},
                "expected_contains": "I'm here to help"
            },
            {
                "input": {"message": "Random message", "response": ""},
                "expected_contains": "I processed your message"
            }
        ]
        
        for i, test_case in enumerate(test_cases):
            result = app.invoke(test_case["input"])
            assert test_case["expected_contains"] in result["response"], \
                f"Test case {i+1} failed: expected '{test_case['expected_contains']}' in response"
        
        print("✅ Complete application tests passed!")
        return True
        
    except Exception as e:
        print(f"❌ Complete application test failed: {e}")
        return False


def run_all_tests():
    """
    Run all tests for the simple graph application.
    
    Returns:
        bool: True if all tests pass, False otherwise
    """
    print("🧪 Running Simple Graph Application Tests...")
    print("=" * 50)
    
    tests = [
        ("State Schema", test_state_schema),
        ("Node Function", test_node_function),
        ("Graph Structure", test_graph_structure),
        ("Complete Application", test_complete_application)
    ]
    
    all_passed = True
    
    for test_name, test_func in tests:
        print(f"\n📋 Testing: {test_name}")
        try:
            result = test_func()
            if not result:
                all_passed = False
        except Exception as e:
            print(f"❌ {test_name} test failed with exception: {e}")
            all_passed = False
    
    print("\n" + "=" * 50)
    if all_passed:
        print("🎉 All tests passed! Simple graph application is working correctly.")
    else:
        print("⚠️  Some tests failed. Please check the implementation.")
    
    return all_passed


if __name__ == "__main__":
    run_all_tests() 